===========
Scikit-Qfit
===========


Scikit-Qfit is a package that supports fitting gradient orthogonal Q-polynomials to 2D data.


Description
===========

This package implements the algorithm described in:

* G W Fobes, `Fitting freeform shapes with orthogonal bases <https://www.osapublishing.org/oe/abstract.cfm?uri=oe-21-16-19061>`_, Opt. Express 21, 19061-19081 (2013)

Additional project documentation and references for Q- freeform polynomials can be found at:
`<http://scikit-qfit.readthedocs.org/>`_.

Installation
============

The package can be installed through pip:

  > pip install scikit-qfit

Usage
=====

To generate a Q-freeform spectrum from a data map, pass the coordinate arrays x and y and 2-D array of
data with shape (x.size,y.size) as arguments to the method qspec(). The azimuthal and radial spectrum
limits are set by m_max and n_max respectively.

  >>> import skqfit.qspectre as qf
  >>> ...
  >>> qspec = qf.qspec(x, y, zmap, m_max=500, n_max=500)

To observe the contribution of spectrum components it is necessary to use the sine and cosine elements in the forward processing step.
After modifying the spectrum, an inverse process creates a data map along with the x and y derivatives.

  >>> qs = qf.QSpectrum()
  >>> qs.data_map(x, y, zmap)
  >>> a_nm, b_nm = qs.q_fit(mmax, nmax)
  >>> ... # modify spectrum
  >>> nmap, dfdx, dfdy = qs.build_map(x, y, a_nm, b_nm, inc_deriv=True)

A 1D trace across the fitted data can also be generated by passing a set of xv, yv arrays that represent the
(x, y) coordinates.

  >>> zv, dfdx, dfdy = qs.build_profile(xv, yv, a_nm, b_nm, inc_deriv=True)


Limitations
===========

The Jacobian polynomial calculation required by the algorithm can generate very large numbers which limits spectral resolution
to a maximum of 1500 for the radial and azimuthal terms (n, m). Using values greater than this can lead to an overflow.
If the nominal spectral resolution for a datamap is greater than this limit the data should be filtered prior to processing
to avoid aliasing.


Note that the process is an N^2 algorithm, so doubling the number of radial and azimuthal terms takes four times as long.


Dependencies
============

The package requires numpy and scipy and was tested on Linux with:

 * Python 2.7.6
 * numpy 1.14.5
 * scipy 1.0.0

These python, numpy and scipy versions were available on the Ubuntu 18.04 Linux release at the time of testing.
The package has been informally tested with python 3.6 successfully and I am not aware of reason it should not work with
later releases of these packages.

Acknowledge
===========

* Greg Forbes for support with the implementation and validation of the algorithm.
* Andreas Beutler, `Mahr GmbH <http://www.mahr.com/>`_, for choosing to make this work available as open source.

Note
====


This project has been set up using PyScaffold 3.2.1. For details and usage
information on PyScaffold see https://pyscaffold.org/.
